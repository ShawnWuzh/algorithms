'''
有一个整型数组arr和一个大小为w的窗口从数组的最左边滑到最右边,窗口每次向右边滑一个位置。 返回一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。 以数组为[4,3,5,4,3,3,6,7]，w=3为例。因为第一个窗口[4,3,5]的最大值为5，第二个窗口[3,5,4]的最大值为5，第三个窗口[5,4,3]的最大值为5。第四个窗口[4,3,3]的最大值为4。第五个窗口[3,3,6]的最大值为6。第六个窗口[3,6,7]的最大值为7。所以最终返回[5,5,5,4,6,7]。
给定整形数组arr及它的大小n，同时给定w，请返回res数组。保证w小于等于n，同时保证数组大小小于等于500。
测试样例：
[4,3,5,4,3,3,6,7],8,3
返回：[5,5,5,4,6,7]
要求保证时间复杂度为O(N)
'''
'''
如果我们采用暴力求解的话，就是针对每一个窗口，我们遍历这个窗口，然后得到最大值，如果采用这种方式的话，最终的时间复杂度为O(N*W)。显然不符合题目要求。由于我们的窗口每次往右只是
移动一位，那么前一个窗口的最大值信息，其实是能对下一个窗口起到参考作用，我们完全可以利用好前一个窗口的信息。我们可以用一个双端队列来保存最大值的下标，当当前值小于队尾值的时候，我们把当前值
放到队列的尾部，当当前值大于队尾值的时候，我们删除队尾值，然后继续比较队尾值和当前值，直到找到一个位置安放当前值。然后从每次遇到一个值，我们检查队列的最前面的下标在不在当前窗口内，如果
在，则将队列第一个值添加到结果中.
'''
# written by HighW
class SlideWindow:
    def slide(self, arr, n, w):
        max_queue = []
        result = []
        for i in range(len(arr)):
            while(len(max_queue) and arr[i] > arr[max_queue[-1]]):
                max_queue.pop()
            max_queue.append(i)
            if i >= w - 1:
                while(len(max_queue) and max_queue[0] < i - w + 1):
                    max_queue.pop(0)
                result.append(arr[max_queue[0]])
        return result

if __name__ == '__main__':
    arr = [4,3,5,4,3,3,6,7]
    window = SlideWindow()
    print(window.slide(arr,8,3))
